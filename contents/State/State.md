---
date: '2023-04-20'
title: '비동기 동작과 클로저 in React'
categories: ['React']
summary: 'React에서의 setState 비동기 동작과 클로저'
thumbnail: './closures.png'
--- 

## React에서의 setState 비동기 동작과 클로저

React에서 상태를 관리할 때 `useState`와 `setState`를 사용하는 것은 중요한 부분이다. 
특히 `setState`의 비동기 동작과 클로저의 개념은 아직까지도 헷가릴때가 있다. 
`setState`의 비동기 동작과 클로저의 관계에 대해 알아보고, 주의할 점들을 살펴보자.

### `setState`의 비동기 동작

React의 `setState` 함수는 상태를 업데이트할 때 비동기적으로 동작한다. 이는 상태를 즉시 변경하지 않고, React가 상태 업데이트를 일괄 처리하고 다음 렌더링 사이클에서 업데이트된 상태를 반영한다는 의미 이로 인해 예상치 못한 결과가 발생할 수 있으므로 주의가 필요하다.

예를 들어,

```js
const [count, setCount] = useState(0);

setCount(count + 1);
console.log(count); // 이 부분은 업데이트된 count 값을 반영하지 않을 수 있습니다.
```

위 코드에서 setCount(count + 1)이 호출되면 count 상태가 즉시 업데이트되는 것이 아니라, React가 상태 업데이트를 일괄 처리한다. 따라서 console.log(count)의 출력은 업데이트된 count 값을 반영하지 않을 수 있다.

이를 해결하기 위해서는 setCount 함수에 함수를 전달하여 이전 상태를 사용하는 방법:

```js
Copy code
setCount(prevCount => prevCount + 1);
```
### 클로저와 setState
React 컴포넌트 내부에서 함수를 정의할 때, 클로저의 개념이 중요하다. 내부 함수에서 외부 함수의 상태를 참조할 때, 해당 상태는 클로저에 의해 해당 함수의 렉시컬 스코프(lexical scope)에 캡쳐된다. 그러나 setState가 비동기적으로 동작하기 때문에, 외부 함수가 종료된 이후에도 내부 함수가 실행될 수 있다. 이 경우에는 클로저가 외부 함수의 상태를 캡쳐하지만, 그 상태가 이미 업데이트되었을 수 있으므로 내부 함수에서 상태를 참조할 때 최신 값을 가져오지 못할 수 있다.

++***렉시컬 스코프(lexical scope)란?***  함수가 선언될 때의 스코프를 의미합니다. 함수가 어디에서 호출되었는지가 아니라, 함수가 어디에 선언되었는지에 따라 해당 함수가 접근할 수 있는 변수의 범위가 결정됩니다.

### 주의사항
setState를 사용할 때는 상태 업데이트 이후에 원하는 동작을 수행하기 위해 setState의 콜백 함수나 useEffect 훅을 활용해야 한다.
내부 함수에서 상태를 참조할 때는 최신 값을 가져오기 위해 클로저를 활용하는 것이 중요하다.
React에서 상태 관리는 매우 중요한 부분이므로, 이러한 동작 원리와 주의사항을 숙지하고 사용하는 것이 좋을것 같다.